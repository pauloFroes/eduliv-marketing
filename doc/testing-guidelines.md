# Padr√µes de Testes

Este documento define as regras para escrita de testes, cobertura e organiza√ß√£o no projeto.

## üìã √çndice

1. [Estrutura de Testes](#estrutura-de-testes)
2. [Padr√£o AAA](#padr√£o-aaa)
3. [Descri√ß√µes de Testes](#descri√ß√µes-de-testes)
4. [Cobertura de Cen√°rios](#cobertura-de-cen√°rios)
5. [Organiza√ß√£o por Cen√°rios](#organiza√ß√£o-por-cen√°rios)
6. [Vari√°veis Descritivas](#vari√°veis-descritivas)
7. [Assertions Espec√≠ficas](#assertions-espec√≠ficas)
8. [Checklist](#checklist)

---

## üß™ Estrutura de Testes

### Nomenclatura de Arquivos

**Siga o padr√£o: `[arquivo-testado].[tipo].test.ts`**

```
‚ùå Antes                    ‚úÖ Depois
user.test.ts ‚Üí user.service.test.ts
test.ts ‚Üí cookie.helper.test.ts
auth.test.ts ‚Üí auth.service.test.ts
```

### Estrutura Hier√°rquica

**Use `describe` blocks para organizar cen√°rios:**

```ts
describe('Nome do Helper/Servi√ßo', () => {
  describe('nomeDaFun√ß√£o', () => {
    describe('quando [condi√ß√£o espec√≠fica]', () => {
      it('deve [comportamento esperado] quando [varia√ß√£o de entrada]', () => {
        // teste
      })
    })
  })
})
```

---

## üéØ Padr√£o AAA

### Arrange - Act - Assert

**Sempre use coment√°rios para separar as se√ß√µes:**

```ts
it('deve retornar o primeiro nome quando receber nome completo', () => {
  // Arrange
  const fullName = 'Jo√£o Silva Santos'

  // Act
  const result = getFirstName(fullName)

  // Assert
  expect(result).toBe('Jo√£o')
})
```

### Regras do AAA

**Arrange:**

- ‚úÖ Declare todas as vari√°veis de entrada
- ‚úÖ Configure mocks quando necess√°rio
- ‚úÖ Use nomes descritivos para vari√°veis

**Act:**

- ‚úÖ Execute apenas a fun√ß√£o sendo testada
- ‚úÖ Armazene o resultado em uma vari√°vel se necess√°rio

**Assert:**

- ‚úÖ Verifique o resultado esperado
- ‚úÖ Use assertions espec√≠ficas
- ‚úÖ Verifique comportamentos colaterais quando relevante

---

## üìù Descri√ß√µes de Testes

### Padr√£o de Descri√ß√£o

**Use o formato: `deve [comportamento esperado] quando [condi√ß√£o/entrada]`**

```ts
// ‚úÖ Descri√ß√µes claras e espec√≠ficas
it('deve retornar o primeiro nome quando receber nome completo', () => {})
it('deve mostrar toast de sucesso quando promise resolve com success: true', () => {})
it('deve executar actionOnSuccess quando fornecido e promise resolve com success: true', () => {})
it('deve mostrar erro padr√£o quando errorMap n√£o cont√©m o erro espec√≠fico', () => {})
it('deve n√£o executar actionOnSuccess quando promise resolve com success: false', () => {})
```

### ‚ùå Evite

```ts
// ‚ùå Descri√ß√µes vagas
it('should work', () => {})
it('testes o comportamento', () => {})
it('funciona corretamente', () => {})
```

---

## üéØ Cobertura de Cen√°rios

### Cen√°rios Obrigat√≥rios

**Para cada fun√ß√£o, teste:**

1. **Cen√°rio de sucesso principal**
2. **Cen√°rios de erro/edge cases**
3. **Varia√ß√µes de entrada**
4. **Comportamentos colaterais**
5. **Valores limites**

### Exemplo de Cobertura Completa

```ts
describe('getFirstName', () => {
  describe('quando receber nome v√°lido', () => {
    it('deve retornar o primeiro nome quando receber nome completo', () => {})
    it('deve retornar o nome recebido quando h√° apenas um nome', () => {})
  })

  describe('quando receber entrada inv√°lida', () => {
    it('deve retornar string vazia quando receber nome vazio', () => {})
    it('deve retornar string vazia quando receber nome nulo', () => {})
    it('deve retornar string vazia quando receber nome undefined', () => {})
  })

  describe('quando receber entrada com formata√ß√£o', () => {
    it('deve retornar o primeiro nome sem espa√ßos extras quando receber nome com espa√ßos extras no in√≠cio', () => {})
    it('deve retornar o primeiro nome sem espa√ßos extras quando receber nome com espa√ßos extras no final', () => {})
    it('deve retornar o primeiro nome sem espa√ßos extras quando receber nome com m√∫ltiplos espa√ßos entre palavras', () => {})
  })
})
```

---

## üìÅ Organiza√ß√£o por Cen√°rios

### Use `describe` para Agrupar Cen√°rios Relacionados

```ts
describe('toastPromise', () => {
  describe('quando a promise resolve com success: true', () => {
    // testes de sucesso
  })

  describe('quando a promise resolve com success: false', () => {
    // testes de erro
  })

  describe('quando a promise rejeita', () => {
    // testes de rejei√ß√£o
  })

  describe('mapeamento de erros', () => {
    // testes espec√≠ficos de mapeamento
  })

  describe('comportamento do actionOnSuccess', () => {
    // testes do callback
  })
})
```

### Benef√≠cios da Organiza√ß√£o

- ‚úÖ Facilita encontrar testes espec√≠ficos
- ‚úÖ Agrupa cen√°rios relacionados
- ‚úÖ Melhora a legibilidade
- ‚úÖ Facilita manuten√ß√£o

---

## üè∑Ô∏è Vari√°veis Descritivas

### Use Nomes Espec√≠ficos e Descritivos

```ts
// ‚ùå Nomes gen√©ricos
const promise = Promise.resolve({ success: true })
const message = 'Carregando...'

// ‚úÖ Nomes descritivos
const mockPromise = Promise.resolve({ success: true } as ApiResponse)
const loadingMessage = 'Carregando dados...'
const successMessage = 'Dados carregados com sucesso!'
const errorMap = { validationError: 'Erro de valida√ß√£o encontrado' }
```

### Padr√µes de Nomenclatura

**Para mocks:**

```ts
const mockPromise = Promise.resolve(...)
const mockActionOnSuccess = vi.fn()
const mockApiResponse = { success: true }
```

**Para mensagens:**

```ts
const loadingMessage = 'Processando...'
const successMessage = 'Processado com sucesso!'
const errorMessage = 'Erro de valida√ß√£o'
```

**Para configura√ß√µes:**

```ts
const errorMap = { validationError: 'Erro de valida√ß√£o' }
const partialErrorMap = { validationError: 'Erro de valida√ß√£o' }
```

---

## ‚úÖ Assertions Espec√≠ficas

### Use Assertions Detalhadas

```ts
// ‚ùå Assertions gen√©ricas
expect(result).toBeTruthy()
expect(mockFunction).toHaveBeenCalled()

// ‚úÖ Assertions espec√≠ficas
expect(result).toBe('Jo√£o')
expect(mockFunction).toHaveBeenCalledTimes(1)
expect(mockFunction).toHaveBeenCalledWith('specific-param')
expect(mockFunction).not.toHaveBeenCalled()
```

### Padr√µes de Assertion

**Para resultados:**

```ts
expect(result).toBe(expectedValue)
expect(result).toEqual(expectedObject)
expect(result).toContain(expectedItem)
```

**Para mocks:**

```ts
expect(mockFunction).toHaveBeenCalled()
expect(mockFunction).toHaveBeenCalledTimes(1)
expect(mockFunction).toHaveBeenCalledWith(expectedParams)
expect(mockFunction).not.toHaveBeenCalled()
```

**Para verifica√ß√µes negativas:**

```ts
expect(toast.error).not.toHaveBeenCalled()
expect(mockActionOnSuccess).not.toHaveBeenCalled()
```

---

## üß™ Cobertura de Testes Espec√≠fica

### Para Fun√ß√µes Helper

**Teste todas as varia√ß√µes de entrada:**

```ts
describe('capitalizeText', () => {
  describe('quando receber texto v√°lido', () => {
    it('deve retornar a primeira letra de cada palavra em mai√∫sculo quando receber texto simples', () => {})
    it('deve retornar a primeira letra de cada palavra em mai√∫sculo quando receber texto j√° capitalizado', () => {})
    it('deve retornar a primeira letra de cada palavra em mai√∫sculo quando receber texto todo em mai√∫sculo', () => {})
  })

  describe('quando receber entrada inv√°lida', () => {
    it('deve retornar string vazia quando receber texto vazio', () => {})
    it('deve retornar string vazia quando receber texto nulo', () => {})
    it('deve retornar string vazia quando receber texto undefined', () => {})
  })

  describe('quando receber texto com formata√ß√£o', () => {
    it('deve retornar a primeira letra de cada palavra em mai√∫sculo quando receber texto com espa√ßos extras no in√≠cio', () => {})
    it('deve retornar a primeira letra de cada palavra em mai√∫sculo quando receber texto com espa√ßos extras no final', () => {})
    it('deve retornar a primeira letra de cada palavra em mai√∫sculo quando receber texto com m√∫ltiplos espa√ßos entre palavras', () => {})
  })
})
```

### Para Fun√ß√µes de Servi√ßo

**Teste todos os cen√°rios de resposta da API:**

```ts
describe('toastPromise', () => {
  describe('quando a promise resolve com success: true', () => {
    it('deve mostrar toast de loading e depois toast de sucesso', () => {})
    it('deve executar actionOnSuccess quando fornecido e promise resolve com success: true', () => {})
  })

  describe('quando a promise resolve com success: false', () => {
    it('deve mostrar toast de loading e depois toast de erro com mensagem do errorMap', () => {})
    it('deve mostrar erro padr√£o quando errorMap n√£o cont√©m o erro espec√≠fico', () => {})
    it('deve mostrar erro padr√£o quando errorMap n√£o √© fornecido', () => {})
    it('deve mostrar erro padr√£o quando error √© undefined', () => {})
    it('deve mostrar erro padr√£o quando resultado n√£o possui propriedade success', () => {})
    it('deve n√£o executar actionOnSuccess quando promise resolve com success: false', () => {})
  })

  describe('quando a promise rejeita', () => {
    it('deve mostrar toast de loading e depois toast de erro padr√£o', () => {})
    it('deve mostrar toast de loading e depois toast de erro padr√£o quando rejeita com string', () => {})
    it('deve mostrar toast de loading e depois toast de erro padr√£o quando rejeita sem par√¢metros', () => {})
    it('deve n√£o executar actionOnSuccess quando promise rejeita', () => {})
  })
})
```

---

## ‚úÖ Checklist

### Antes de Escrever Testes

- [ ] Entendi completamente o comportamento da fun√ß√£o?
- [ ] Identifiquei todos os cen√°rios poss√≠veis?
- [ ] Identifiquei todas as varia√ß√µes de entrada?
- [ ] Identifiquei todos os comportamentos colaterais?

### Durante a Escrita

- [ ] Descri√ß√£o do teste √© clara e espec√≠fica?
- [ ] Vari√°veis t√™m nomes descritivos?
- [ ] Segui o padr√£o AAA com coment√°rios?
- [ ] Assertions s√£o espec√≠ficas e detalhadas?
- [ ] Teste cobre apenas um cen√°rio espec√≠fico?

### Para Cobertura Completa

- [ ] Testei o cen√°rio de sucesso principal?
- [ ] Testei todos os cen√°rios de erro?
- [ ] Testei varia√ß√µes de entrada?
- [ ] Testei valores limites?
- [ ] Testei comportamentos colaterais?
- [ ] Testei casos edge (nulo, undefined, vazio)?

### Organiza√ß√£o

- [ ] Testes est√£o organizados em `describe` blocks?
- [ ] Cen√°rios relacionados est√£o agrupados?
- [ ] Estrutura hier√°rquica faz sentido?
- [ ] F√°cil de encontrar testes espec√≠ficos?

### Qualidade

- [ ] Cada teste √© independente?
- [ ] Testes n√£o t√™m depend√™ncias entre si?
- [ ] Mocks s√£o limpos entre testes?
- [ ] Assertions verificam o comportamento correto?
- [ ] Testes s√£o determin√≠sticos?

---

## üìö Exemplos de Refer√™ncia

### Helper Function

```ts
describe('Text Helpers', () => {
  describe('getFirstName', () => {
    it('deve retornar o primeiro nome de um nome completo', () => {
      // Arrange
      const fullName = 'Jo√£o Silva Santos'

      // Act
      const result = getFirstName(fullName)

      // Assert
      expect(result).toBe('Jo√£o')
    })

    it('deve retornar string vazia quando receber nome vazio ou nulo', () => {
      // Arrange
      const emptyName = ''

      // Act
      const result = getFirstName(emptyName)

      // Assert
      expect(result).toBe('')
    })
  })
})
```

### Service Function

```ts
describe('Toast Helpers', () => {
  describe('toastPromise', () => {
    describe('quando a promise resolve com success: true', () => {
      it('deve mostrar toast de loading e depois toast de sucesso', async () => {
        // Arrange
        const mockPromise = Promise.resolve({ success: true } as ApiResponse)
        const loadingMessage = 'Carregando dados...'
        const successMessage = 'Dados carregados com sucesso!'

        // Act
        await toastPromise({
          promise: mockPromise,
          loading: loadingMessage,
          success: successMessage,
        })

        // Assert
        expect(toast.loading).toHaveBeenCalledWith(loadingMessage)
        expect(toast.success).toHaveBeenCalledWith(successMessage, { id: 'toast-id' })
        expect(toast.error).not.toHaveBeenCalled()
      })
    })
  })
})
```
